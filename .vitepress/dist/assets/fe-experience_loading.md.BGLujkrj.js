import{_ as i,c as a,o as t,ag as n}from"./chunks/framework.DPDPlp3K.js";const g=JSON.parse('{"title":"로딩 중인데 NoData가 먼저 보여요 :React Query 로딩 처리","description":"","frontmatter":{},"headers":[],"relativePath":"fe-experience/loading.md","filePath":"fe-experience/loading.md"}'),h={name:"fe-experience/loading.md"};function e(l,s,p,k,d,r){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="로딩-중인데-nodata가-먼저-보여요-react-query-로딩-처리" tabindex="-1">로딩 중인데 NoData가 먼저 보여요 :React Query 로딩 처리 <a class="header-anchor" href="#로딩-중인데-nodata가-먼저-보여요-react-query-로딩-처리" aria-label="Permalink to &quot;로딩 중인데 NoData가 먼저 보여요 :React Query 로딩 처리&quot;">​</a></h1><p>최근 React Query를 사용하는 화면에서 데이터 로딩 중인데도 NoData 컴포넌트가 먼저 렌더링되는 문제를 겪었어요. 사용자 입장에서는 &quot;로딩 중&quot;이 아니라 &quot;진짜로 데이터가 없는 것처럼&quot; 보이기 때문에, UX에 혼란을 줄 수 있었어요.</p><p>처음엔 isLoading을 기준으로 로딩 여부를 판단했지만, 생각보다 예상치 못한 동작이 자주 발생했어요. 그래서 React Query의 status 값을 함께 확인하면서 문제를 해결할 수 있었어요.</p><h2 id="문제-상황-–-로딩인데-nodata-컴포넌트가-먼저-나왔어요" tabindex="-1">문제 상황 – 로딩인데 NoData 컴포넌트가 먼저 나왔어요 <a class="header-anchor" href="#문제-상황-–-로딩인데-nodata-컴포넌트가-먼저-나왔어요" aria-label="Permalink to &quot;문제 상황 – 로딩인데 NoData 컴포넌트가 먼저 나왔어요&quot;">​</a></h2><p>기존에는 아래 코드와 같이 로딩 상태를 처리하고 있었어요:</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isLoading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useQuery</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;users&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], fetchUsers);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isLoading) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NoData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ProductList</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> users</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{data} /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>처음에는 잘 작동하는 듯했지만, 특정 조건에서 isLoading이 false이고 data도 undefined인 경우가 있었어요. 이런 상황에서 <code>&lt;NoData /&gt;</code>가 먼저 보여지고, 바로 이어서 다시 <code>&lt;ProductList /&gt;</code>가 뜨는 일이 발생했어요. 결과적으로는 로딩 상태를 정확히 인식하지 못한 조건 분기가 문제였어요.</p><h2 id="원인-–-isloading만으로는-충분하지-않았어요" tabindex="-1">원인 – isLoading만으로는 충분하지 않았어요 <a class="header-anchor" href="#원인-–-isloading만으로는-충분하지-않았어요" aria-label="Permalink to &quot;원인 – isLoading만으로는 충분하지 않았어요&quot;">​</a></h2><p>React Query에서는 isLoading 외에도 status, isFetching, isSuccess, isError 등 다양한 상태 값을 제공해요. isLoading은 일반적으로 첫 번째 요청일 때만 true가 되지만, 캐시 상태나 리페치 전략에 따라 정확한 시점을 잡기 어려울 수 있어요.</p><p>❗️isLoading만을 기준으로 로딩 상태를 판단하면 아직 데이터를 받지 못했지만 isLoading이 false인 상태를 처리하지 못할 수 있어요.</p><details class="details custom-block"><summary>🔍 왜 isLoading이 true일 때 data가 undefined일까?</summary><p>React Query에서 useQuery()를 처음 호출하면 기본적으로 아직 데이터를 받아오지 않았기 때문에 data는 undefined 상태예요.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isLoading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useQuery</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;users&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], fetchUsers);</span></span></code></pre></div><p>이 시점에서 React Query는 아직 fetchUsers() 요청을 보내는 중이고, 응답이 오지 않았기 때문에 data는 존재하지 않아요.</p><p>초기상태:</p><ul><li>isLoading: true</li><li>data: undefined</li><li>status: &#39;pending&#39;</li></ul><p>이 상태에서 data.length 같은 코드를 실행하면 JS 입장에선 &quot;undefined에 length 속성이 없다&quot;고 판단해서 오류는 아니지만, false 또는 undefined로 처리될 수 있어요. 그래서 조건문에서 !data || data.length === 0 이런 식으로 걸어두면, 아직 로딩 중인데도 빈 데이터 상태로 오인할 수 있는 거죠.</p><table tabindex="0"><thead><tr><th>상태</th><th>data 값</th><th>isLoading</th><th>status</th><th>설명</th></tr></thead><tbody><tr><td>초기 로딩 중</td><td>undefined</td><td>true</td><td>&#39;pending&#39;</td><td>데이터 요청 중</td></tr><tr><td>로딩 성공 (데이터 O)</td><td><code>[...]</code></td><td>false</td><td>&#39;success&#39;</td><td>정상 응답</td></tr><tr><td>로딩 성공 (데이터 X)</td><td><code>[]</code></td><td>false</td><td>&#39;success&#39;</td><td>응답은 왔지만 데이터 없음</td></tr><tr><td>에러 발생</td><td>undefined</td><td>false</td><td>&#39;error&#39;</td><td>요청 실패</td></tr></tbody></table></details><h2 id="해결" tabindex="-1">해결 <a class="header-anchor" href="#해결" aria-label="Permalink to &quot;해결&quot;">​</a></h2><p>React Query의 status는 &#39;pending&#39; | &#39;success&#39; | &#39;error&#39; 중 하나의 값을 가지기 때문에, 이를 함께 사용해서 명확하게 조건을 나눴어요.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isLoading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useQuery</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;users&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], fetchUsers);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;pending&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isLoading) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NoData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ProductList</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> users</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{data} /&gt;;</span></span></code></pre></div><p>isLoading || status === &#39;pending&#39;보다는 status === &#39;pending&#39;만 단독적으로 사용하는 방식이 더 명확하고 디버깅하기도 쉬울거같기도 해요.</p><h2 id="추가-내용-–-suspense를-사용하는-경우" tabindex="-1">추가 내용 – suspense를 사용하는 경우 <a class="header-anchor" href="#추가-내용-–-suspense를-사용하는-경우" aria-label="Permalink to &quot;추가 내용 – suspense를 사용하는 경우&quot;">​</a></h2><p>React Query에서 suspense: true 옵션을 사용한다면 로딩 처리는 <code>&lt;Suspense&gt;</code>로 감싸서 처리할 수도 있어요.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 컴포넌트에서</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fallback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ProductListPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>이 방식은 더 깔끔하고 선언적이지만, 일부 상황에서는 유연하게 상태를 나누기 어려울 수도 있기 때문에 선택적으로 사용하면 좋아요.</p><h2 id="마무리하며" tabindex="-1">마무리하며 <a class="header-anchor" href="#마무리하며" aria-label="Permalink to &quot;마무리하며&quot;">​</a></h2><p>React Query는 정말 강력한 도구이지만, 상태 관리를 섬세하게 하지 않으면 의도치 않은 UI가 렌더링되기도 한다는 것을 주의 해야해요. 이번 경험을 통해 단순히 isLoading만 보는 것보다는 status를 함께 활용하는 것이 훨씬 명확하고 안정적이라는 걸 알게 되었어요.</p><p>특히 초기 로딩과 빈 데이터 상태를 구분할 수 있게 되는 것만으로도 사용자 경험이 훨씬 깔끔해졌어요.</p>`,22)]))}const o=i(h,[["render",e]]);export{g as __pageData,o as default};
